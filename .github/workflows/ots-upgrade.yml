name: ots-upgrade
on:
  schedule:
    - cron: "*/30 * * * *"
  workflow_dispatch: {}
  workflow_run:
    workflows:
      - releases-manifest
    types:
      - completed
  push:
    paths:
      - "docs/letter.md.asc"
      - "docs/index.html"

concurrency:
  group: letter-artifacts-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  actions: read

jobs:
  precheck:
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.decision.outputs.should_run }}
    steps:
      - name: Determine whether scheduled run should proceed
        id: decision
        shell: bash
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref_name }}
          REF: ${{ github.ref }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
          REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail

          if [[ "${EVENT_NAME}" != "schedule" ]]; then
            echo "Event '${EVENT_NAME}' is not schedule; proceeding."
            printf 'should_run=%s\n' 'true' >> "$GITHUB_OUTPUT"
            exit 0
          fi

          python - <<'PY'
          import io
          import json
          import os
          import re
          import subprocess
          import sys
          from urllib.error import URLError, HTTPError
          from urllib.request import urlopen
          
          
          def log(msg: str) -> None:
              print(msg)
          
          
          def determine_branch() -> str:
              branch = os.environ.get("REF_NAME")
              ref = os.environ.get("REF", "")
              default = os.environ.get("DEFAULT_BRANCH")
          
              if not branch and ref.startswith("refs/heads/"):
                  branch = ref.split("/", 2)[-1]
              if not branch and default:
                  branch = default
              if not branch:
                  branch = "main"
              return branch
          
          
          from typing import Optional


          def fetch_text(url: str) -> Optional[str]:
              log(f"Fetching {url} ...")
              try:
                  with urlopen(url) as resp:
                      return resp.read().decode("utf-8", "replace")
              except (URLError, HTTPError) as exc:
                  log(f"Failed to fetch {url}: {exc}")
                  return None
          
          
          def fetch_bytes(url: str) -> Optional[bytes]:
              log(f"Fetching {url} (binary) ...")
              try:
                  with urlopen(url) as resp:
                      return resp.read()
              except (URLError, HTTPError) as exc:
                  log(f"Failed to fetch {url}: {exc}")
                  return None
          
          
          def ensure_opentimestamps() -> bool:
              try:
                  import opentimestamps  # type: ignore  # noqa: F401
                  return True
              except ImportError:
                  log("Installing opentimestamps-client for block height extraction ...")
                  try:
                      subprocess.run(
                          [sys.executable, "-m", "pip", "install", "--quiet", "opentimestamps-client"],
                          check=True,
                          stdout=subprocess.DEVNULL,
                          stderr=subprocess.DEVNULL,
                      )
                  except Exception as exc:  # pragma: no cover - best-effort installer
                      log(f"pip install failed: {exc}")
                      return False
              try:
                  import opentimestamps  # type: ignore  # noqa: F401
                  return True
              except ImportError:
                  log("Unable to import opentimestamps after installation attempt.")
                  return False
          
          
          def extract_ots_height(data: bytes) -> str:
              if not data:
                  return ""
              if not ensure_opentimestamps():
                  return ""
              try:
                  from opentimestamps.core.serialize import StreamDeserializationContext
                  from opentimestamps.core.timestamp import DetachedTimestampFile
                  from opentimestamps.core.notary import BitcoinBlockHeaderAttestation
              except Exception as exc:  # pragma: no cover - depends on package internals
                  log(f"Unable to import OpenTimestamps parser: {exc}")
                  return ""
          
              try:
                  ctx = StreamDeserializationContext(io.BytesIO(data))
                  timestamp = DetachedTimestampFile.deserialize(ctx).timestamp
              except Exception as exc:  # pragma: no cover - invalid proof
                  log(f"Failed to parse OTS proof: {exc}")
                  return ""
          
              heights = sorted({
                  att.height
                  for _path, att in timestamp.all_attestations()
                  if isinstance(att, BitcoinBlockHeaderAttestation)
              })
              if not heights:
                  return ""
              return str(heights[-1])
          
          
          def write_output(value: bool) -> None:
              out_path = os.environ.get("GITHUB_OUTPUT")
              if not out_path:
                  return
              with open(out_path, "a", encoding="utf-8") as fh:
                  fh.write(f"should_run={'true' if value else 'false'}\n")
          
          
          def main() -> int:
              repository = os.environ["REPOSITORY"]
              branch = determine_branch()
          
              base = f"https://raw.githubusercontent.com/{repository}/{branch}"
          
              index_html = fetch_text(f"{base}/docs/index.html")
              if index_html is None:
                  log("Unable to inspect docs/index.html; allowing workflow to proceed.")
                  write_output(True)
                  return 0
          
              version_match = re.search(r"<!--\s*release-version:\s*v?([0-9][0-9.]+)\s*-->", index_html)
              index_version = version_match.group(1) if version_match else ""
              height_match = re.search(r"Bitcoin block <strong>([0-9]+)</strong>", index_html)
              index_height = height_match.group(1) if height_match else ""
          
              releases_raw = fetch_text(f"{base}/letter/RELEASES.json")
              if releases_raw is None:
                  log("Unable to inspect RELEASES.json; allowing workflow to proceed.")
                  write_output(True)
                  return 0
          
              try:
                  releases = json.loads(releases_raw)
              except json.JSONDecodeError as exc:
                  log(f"Failed to parse RELEASES.json: {exc}")
                  write_output(True)
                  return 0
          
              release_entry = None
              releases_list = releases.get("releases") or []
              if index_version:
                  for candidate in releases_list:
                      if candidate.get("version") == index_version:
                          release_entry = candidate
                          break
              if release_entry is None and releases_list:
                  release_entry = releases_list[0]
          
              if release_entry is None:
                  log("No releases found; allowing workflow to proceed.")
                  write_output(True)
                  return 0
          
              ots_path = (
                  release_entry.get("files", {})
                  .get("ots", {})
                  .get("path")
              )
              if not ots_path:
                  log("Latest release lacks an OTS proof path; allowing workflow to proceed.")
                  write_output(True)
                  return 0
          
              ots_bytes = fetch_bytes(f"{base}/{ots_path}")
              ots_height = extract_ots_height(ots_bytes or b"")
          
              if ots_height and index_height == ots_height:
                  log(
                      f"Detected finalized Bitcoin block {index_height} for current letter; skipping scheduled run."
                  )
                  write_output(False)
                  return 0
          
              log(
                  "Proof not yet finalized for current letter (index height: "
                  f"{index_height or 'n/a'}, proof height: {ots_height or 'n/a'}); proceeding."
              )
              write_output(True)
              return 0
          
          
          if __name__ == "__main__":
              sys.exit(main())
          PY

  upgrade-and-update:
    needs: precheck
    if: ${{ (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success') && needs.precheck.outputs.should_run == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install OpenTimestamps client + alt verifier
        run: |
          python -m pip install --upgrade opentimestamps-client
          wget -q https://go.dev/dl/go1.22.5.linux-amd64.tar.gz
          sudo rm -rf /usr/local/go
          sudo tar -C /usr/local -xzf go1.22.5.linux-amd64.tar.gz
          echo "/usr/local/go/bin" >> $GITHUB_PATH
          echo "GOROOT=/usr/local/go" >> $GITHUB_ENV
          /usr/local/go/bin/go install github.com/fiatjaf/ots@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH

      - name: Prepare proof + determine footer status
        id: status
        shell: bash
        run: |
          set -euo pipefail

          STATUS="Bitcoin anchoring pending. Proof will update automatically."
          TARGET=""

          if [[ -f letter/RELEASES.json ]]; then
            TARGET="$(
              python - <<'PY'
              import json
              from pathlib import Path


              def main() -> None:
                  try:
                      with Path('letter/RELEASES.json').open('r', encoding='utf-8') as fh:
                          payload = json.load(fh)
                  except Exception:
                      return

                  releases = payload.get('releases') or []
                  if not releases:
                      return

                  latest = releases[0] or {}
                  path = (
                      (latest.get('files') or {})
                      .get('asc')
                      or {}
                  ).get('path')
                  if not path:
                      return

                  resolved = Path(path)
                  if resolved.is_file():
                      print(resolved.as_posix())


              if __name__ == '__main__':
                  main()
              PY
            )"
          fi

          if [[ -z "$TARGET" ]] && ls letter/*.asc 1>/dev/null 2>&1; then
            TARGET="$(ls letter/*.asc | sort | tail -n1)"
          fi

          if [[ -z "$TARGET" ]] && [[ -f docs/letter.md.asc ]]; then
            TARGET="docs/letter.md.asc"
          fi

          if [[ -n "$TARGET" ]]; then
            echo "Using TARGET='$TARGET'"
            if [[ ! -f "${TARGET}.ots" ]]; then
              echo "No .ots present; stamping"
              if ots stamp "$TARGET"; then
                echo "Stamp completed"
              else
                echo "Warning: ots stamp failed; continuing without a freshly stamped proof" >&2
              fi
            else
              echo "Found ${TARGET}.ots; skipping stamp."
            fi

            ots upgrade "${TARGET}.ots" || true

            if [[ -f "${TARGET}.ots" ]]; then
              git add "${TARGET}.ots"

              cp "${TARGET}.ots" /tmp/proof.ots
              ots upgrade /tmp/proof.ots || true

              HEIGHT=""
              if PY_OUT="$(python .github/scripts/extract_block_height.py /tmp/proof.ots)"; then
                HEIGHT="${PY_OUT//$'\n'/}"
                HEIGHT="${HEIGHT//$'\r'/}"
              fi

              if [[ -z "$HEIGHT" ]]; then
                set +e
                OUT="$(ots verify /tmp/proof.ots 2>&1)"
                ALT="$("$HOME/go/bin/ots" verify /tmp/proof.ots 2>&1)"
                INFO="$(ots info /tmp/proof.ots 2>&1)"
                OUT="$OUT"$'\n'"$ALT"$'\n'"$INFO"
                set -e
                HEIGHT="$(echo "$OUT" |
                  grep -Eo 'block[[:space:]]*#?[0-9]+|blockheight[[:space:]]*#?[0-9]+|BitcoinBlockHeaderAttestation\([0-9]+\)' |
                  grep -Eo '[0-9]+' |
                  tail -n1 || true)"
              fi

              if [[ -n "$HEIGHT" ]]; then
                STATUS="Bitcoin block <strong>${HEIGHT}</strong> attests the letter existed prior to that block."
              fi
            fi
          fi

          STATUS_SANITIZED="$(printf '%s' "$STATUS" | tr '\n' ' ' | tr -d '\r')"
          printf 'status_line=%s\n' "$STATUS_SANITIZED" >> "$GITHUB_OUTPUT"

      - name: Ensure footer (scriptless, centered)
        shell: bash
        env:
          STATUS_LINE: ${{ steps.status.outputs.status_line }}
        run: |
          set -euo pipefail

          HTML="docs/index.html"
          [[ -f "$HTML" ]] || { echo "Missing $HTML" >&2; exit 1; }

          # Remove any prior OTS blocks or stray legacy script tags
          perl -0777 -pe 's/<!-- OTS-START -->.*?<!-- OTS-END -->\s*//gs; s#<script id="ots-proof".*?</script>\s*##gs' -i "$HTML"

          STATUS="${STATUS_LINE:-Bitcoin anchoring pending. Proof will update automatically.}"

          {
            printf '%s\n' '<!-- OTS-START -->'
            printf '%s\n' '<section id="timestamp-proof" style="max-width:48rem;margin:2rem auto 0 auto;padding-top:1rem;border-top:1px solid #e5e7eb;text-align:center;font-size:0.95rem;line-height:1.5;">'
            printf '%s\n' '  <h3 style="margin:0 0 .5rem 0;font-size:1.05rem;">Timestamp proof (Bitcoin)</h3>'
            printf '  <p id="ots-line">%s</p>\n' "${STATUS}"
            printf '%s\n' '</section>'
            printf '%s\n' '<!-- OTS-END -->'
          } >> "$HTML"

      - name: Rebase onto latest ${{ github.ref_name }} before committing
        shell: bash
        run: |
          set -euo pipefail
          branch="${GITHUB_REF##*/}"
          git fetch origin "$branch"
          git pull --rebase --autostash origin "$branch"

      - name: Wait for GitHub Pages to be idle
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: .github/scripts/wait_for_pages_idle.sh

      - uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore(ots): upgrade proof + refresh status [ots-upgrade-auto]"
          file_pattern: |
            docs/index.html
            letter/*.ots
            docs/*.ots

