name: ots-upgrade
on:
  schedule:
    - cron: "*/30 * * * *"
  workflow_dispatch: {}
  workflow_run:
    workflows:
      - releases-manifest
    types:
      - completed
  push:
    branches:
      - main
    paths:
      - "docs/letter.md"
      - "docs/index.html"

concurrency:
  group: letter-artifacts-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  actions: read

jobs:
  precheck:
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.decision.outputs.should_run }}
    steps:
      - name: Determine whether scheduled run should proceed
        id: decision
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref_name }}
          REF: ${{ github.ref }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          python - <<'PY'
          import base64
          import html
          import json
          import os
          import re
          import sys
          import urllib.parse
          import urllib.request

          event_name = os.environ.get('EVENT_NAME', '')
          gh_output = os.environ.get('GITHUB_OUTPUT')
          if not gh_output:
              raise SystemExit('GITHUB_OUTPUT is not set')

          token = os.environ.get('GITHUB_TOKEN', '')

          def detect_block(document):
              if not document:
                  return None

              normalized = html.unescape(document)
              normalized = normalized.replace('\r', ' ')

              patterns = [
                  re.compile(r'Bitcoin\s+block[^<]*<strong>\s*#?([\d,]+)', re.IGNORECASE),
                  re.compile(r'blockheight[^<]*<strong>\s*#?([\d,]+)', re.IGNORECASE),
                  re.compile(r'BitcoinBlockHeaderAttestation\((\d+)\)', re.IGNORECASE),
              ]

              for pattern in patterns:
                  match = pattern.search(normalized)
                  if match:
                      digits = re.sub(r'\D', '', match.group(1))
                      if digits:
                          return digits
              return None

          with open(gh_output, 'a', encoding='utf-8') as out:
              if event_name != 'schedule':
                  print(f"Event '{event_name}' is not schedule; proceeding.")
                  print('should_run=true', file=out)
                  raise SystemExit(0)

              ref_name = os.environ.get('REF_NAME') or ''
              if not ref_name:
                  ref = os.environ.get('REF', '')
                  if ref.startswith('refs/heads/'):
                      ref_name = ref.split('/', 2)[2]
              if not ref_name:
                  ref_name = os.environ.get('DEFAULT_BRANCH', 'main') or 'main'

              repository = os.environ.get('REPOSITORY')
              if not repository:
                  print('Missing repository context; proceeding.', file=sys.stderr)
                  print('should_run=true', file=out)
                  raise SystemExit(0)

              url = f"https://raw.githubusercontent.com/{repository}/{ref_name}/docs/index.html"
              print(f"Fetching {url}")

              headers = {
                  'User-Agent': 'asi-letter-ots-precheck',
                  'Cache-Control': 'no-cache',
                  'Pragma': 'no-cache',
              }
              if token:
                  headers['Authorization'] = f'Bearer {token}'

              raw_request = urllib.request.Request(url, headers=headers)

              document = None
              try:
                  with urllib.request.urlopen(raw_request, timeout=30) as resp:
                      encoding = resp.headers.get_content_charset() or 'utf-8'
                      document = resp.read().decode(encoding, 'replace')
              except Exception as exc:
                  print(f"Raw download failed: {exc}", file=sys.stderr)

              # Fall back to the contents API when the raw download is unavailable.
              if document is None and token:
                  api_url = "https://api.github.com/repos/{repo}/contents/docs/index.html?ref={ref}".format(
                      repo=repository,
                      ref=urllib.parse.quote(ref_name, safe=''),
                  )
                  api_request = urllib.request.Request(
                      api_url,
                      headers={
                          'User-Agent': 'asi-letter-ots-precheck',
                          'Authorization': f'Bearer {token}',
                          'Accept': 'application/vnd.github+json',
                      },
                  )
                  try:
                      with urllib.request.urlopen(api_request, timeout=30) as resp:
                          payload = resp.read().decode('utf-8', 'replace')
                          data = json.loads(payload)
                      if isinstance(data, dict) and data.get('type') == 'file':
                          content = data.get('content')
                          encoding = (data.get('encoding') or 'base64').lower()
                          if isinstance(content, str):
                              document = None
                              if encoding == 'base64':
                                  try:
                                      document = base64.b64decode(content).decode('utf-8', 'replace')
                                  except Exception as exc:
                                      print(
                                          f"Unable to decode docs/index.html from API response ({encoding}): {exc}",
                                          file=sys.stderr,
                                      )
                              if document is None:
                                  document = content
                          else:
                              print('docs/index.html content missing or not string in API response; proceeding.', file=sys.stderr)
                      else:
                          print('docs/index.html not returned as file content via API; proceeding.', file=sys.stderr)
                  except Exception as exc:
                      print(f"Contents API fallback failed: {exc}", file=sys.stderr)

              if document:
                  block_digits = detect_block(document)
                  if block_digits:
                      print(
                          f"Detected finalized Bitcoin block in docs/index.html (height {block_digits}); skipping scheduled run."
                      )
                      print('should_run=false', file=out)
                      raise SystemExit(0)

              print('No finalized Bitcoin block detected; proceeding.')
              print('should_run=true', file=out)
          PY

  upgrade-and-update:
    needs: precheck
    if: ${{ (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success') && needs.precheck.outputs.should_run == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install OpenTimestamps client + alt verifier
        run: |
          python -m pip install --upgrade opentimestamps-client
          wget -q https://go.dev/dl/go1.22.5.linux-amd64.tar.gz
          sudo rm -rf /usr/local/go
          sudo tar -C /usr/local -xzf go1.22.5.linux-amd64.tar.gz
          echo "/usr/local/go/bin" >> $GITHUB_PATH
          echo "GOROOT=/usr/local/go" >> $GITHUB_ENV
          /usr/local/go/bin/go install github.com/fiatjaf/ots@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH

      - name: Prepare proof + determine footer status
        id: status
        shell: bash
        run: |
          set -euo pipefail

          STATUS="Bitcoin anchoring pending. Proof will update automatically."
          TARGET=""

          if ls letter/*.asc 1>/dev/null 2>&1; then
            TARGET="$(ls -t letter/*.asc | head -n1)"
          elif [[ -f docs/letter.md.asc ]]; then
            TARGET="docs/letter.md.asc"
          fi

          if [[ -n "$TARGET" ]]; then
            echo "Using TARGET='$TARGET'"
            if [[ ! -f "${TARGET}.ots" ]]; then
              echo "No .ots present; stamping"
              ots stamp "$TARGET"
            else
              echo "Found ${TARGET}.ots; skipping stamp."
            fi

            ots upgrade "${TARGET}.ots" || true

            if [[ -f "${TARGET}.ots" ]]; then
              git add "${TARGET}.ots"

              cp "${TARGET}.ots" /tmp/proof.ots
              ots upgrade /tmp/proof.ots || true

              HEIGHT=""
              if PY_OUT="$(python .github/scripts/extract_block_height.py /tmp/proof.ots)"; then
                HEIGHT="${PY_OUT//$'\n'/}"
                HEIGHT="${HEIGHT//$'\r'/}"
              fi

              if [[ -z "$HEIGHT" ]]; then
                set +e
                OUT="$(ots verify /tmp/proof.ots 2>&1)"
                ALT="$("$HOME/go/bin/ots" verify /tmp/proof.ots 2>&1)"
                INFO="$(ots info /tmp/proof.ots 2>&1)"
                OUT="$OUT"$'\n'"$ALT"$'\n'"$INFO"
                set -e
                HEIGHT="$(echo "$OUT" |
                  grep -Eo 'block[[:space:]]*#?[0-9]+|blockheight[[:space:]]*#?[0-9]+|BitcoinBlockHeaderAttestation\([0-9]+\)' |
                  grep -Eo '[0-9]+' |
                  tail -n1 || true)"
              fi

              if [[ -n "$HEIGHT" ]]; then
                STATUS="Bitcoin block <strong>${HEIGHT}</strong> attests the letter existed prior to that block."
              fi
            fi
          fi

          STATUS_SANITIZED="$(printf '%s' "$STATUS" | tr '\n' ' ' | tr -d '\r')"
          printf 'status_line=%s\n' "$STATUS_SANITIZED" >> "$GITHUB_OUTPUT"

      - name: Ensure footer (scriptless, centered)
        shell: bash
        env:
          STATUS_LINE: ${{ steps.status.outputs.status_line }}
        run: |
          set -euo pipefail

          HTML="docs/index.html"
          [[ -f "$HTML" ]] || { echo "Missing $HTML" >&2; exit 1; }

          # Remove any prior OTS blocks or stray legacy script tags
          perl -0777 -pe 's/<!-- OTS-START -->.*?<!-- OTS-END -->\s*//gs; s#<script id="ots-proof".*?</script>\s*##gs' -i "$HTML"

          STATUS="${STATUS_LINE:-Bitcoin anchoring pending. Proof will update automatically.}"

          {
            printf '%s\n' '<!-- OTS-START -->'
            printf '%s\n' '<section id="timestamp-proof" style="max-width:48rem;margin:2rem auto 0 auto;padding-top:1rem;border-top:1px solid #e5e7eb;text-align:center;font-size:0.95rem;line-height:1.5;">'
            printf '%s\n' '  <h3 style="margin:0 0 .5rem 0;font-size:1.05rem;">Timestamp proof (Bitcoin)</h3>'
            printf '  <p id="ots-line">%s</p>\n' "${STATUS}"
            printf '%s\n' '</section>'
            printf '%s\n' '<!-- OTS-END -->'
          } >> "$HTML"

      - name: Rebase onto latest ${{ github.ref_name }} before committing
        shell: bash
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
        run: |
          set -euo pipefail

          branch="${GITHUB_REF##*/}"
          if [[ -z "$branch" || "$branch" == "$GITHUB_REF" ]]; then
            branch="${DEFAULT_BRANCH:-main}"
          fi

          if git ls-remote --exit-code --heads origin "$branch" >/dev/null 2>&1; then
            git fetch origin "$branch"
            git pull --rebase --autostash origin "$branch"
          else
            echo "Branch '$branch' not published on origin; skipping rebase."
          fi

      - name: Wait for GitHub Pages to be idle
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: .github/scripts/wait_for_pages_idle.sh

      - uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore(ots): upgrade proof + refresh status [ots-upgrade-auto]"
          file_pattern: docs/index.html

